[["index.html", "Holobiont Modelling Framework 1 About", " Holobiont Modelling Framework William S. Pearman, Allen G. Rodrigo, Anna W. Santure 2025-04-28 1 About This site is an introduction to the modelling framework developed by William Pearman, Allen Rodrigo, and Anna Santure. This site will be an ‘evolving’ document, where as we develop extensions to the framework - we will add extra chapters. "],["paper-1---joint-consideration-of-selection-and-microbial-generation-count-provides-unique-insights-into-evolutionary-and-ecological-dynamics-of-holobionts.html", "2 Paper 1 - Joint consideration of selection and microbial generation count provides unique insights into evolutionary and ecological dynamics of holobionts 2.1 Creating offspring function - create_offspring_loop.cpp 2.2 General simulation wrapper code 2.3 Generating environmental pools. 2.4 Generating new microbiomes within a host generation 2.5 Generating new hosts 2.6 Unused functions and capacities 2.7 Running a simulation", " 2 Paper 1 - Joint consideration of selection and microbial generation count provides unique insights into evolutionary and ecological dynamics of holobionts Here I provide a general outline for the framework presented in our paper. 2.1 Creating offspring function - create_offspring_loop.cpp Here we implementing the create offspring function, this essentially takes in a host population and generates the offspring for the subsequent host generation. We determine the individuals which reproduce elsewhere in the code, this just takes those parents and produces offspring children. It functions by calculating the relative abundance of each microbe in the parent, the relative abundance in the environment, and the combines the abundances based on the relative contribution of parent vs environment to the child. The fitness of each microbial taxa in the host is determined and the product of the fitness and the relative abundance determines the sampling probability of that microbe into the offspring. The microbes are then sampled multinomially to produce the offsprings microbiome. We implement this as a C++ R code, because this is executed many many times and it is very slow to run it normally in R. Rcpp::sourceCpp(&quot;./create_offspring_loop.cpp&quot;) Create_OffSpring_Pop_cpp&lt;-function(host_pop,n_micro,env_pool,envpoolsize,X,fixed_envpool, selection_parameter_microbes,selection_parameter_hosts,microbe_trait_list, host_microbe_optima, N_Species,env_condition,weighting){ microbe_names&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) ENV_sampling_probability&lt;-(env_pool)/envpoolsize #Calculate initial sampling probability based on environmental relative abundance names(ENV_sampling_probability)&lt;-names(env_pool) offspring_population&lt;-offspring_loopfunc(host_pop = host_pop,ENV_sampling_probability = ENV_sampling_probability, host_microbe_optima = host_microbe_optima, X = X, selection_parameter_microbes = selection_parameter_microbes, env_condition = env_condition,microbe_trait_list = microbe_trait_list, n_micro = n_micro,microbe_names = microbe_names,weighting=weighting)#, # fitness_microbes = fitness_microbes,weighted_samplingprob = weighted_samplingprob) offspring_population&lt;-list(offspring_population$host_pop,env_pool,microbe_trait_list,offspring_population$fitness_microbes, offspring_population$weighted_samplingprob) names(offspring_population)&lt;-c(&quot;Child&quot;,&quot;Env&quot;,&quot;microbe_trait_list&quot;,&quot;microbefitness&quot;,&quot;microbe_samplingprob&quot;) offspring_population } 2.2 General simulation wrapper code This code first works by calculating initial fitness values so we have them recorded. It loops over N generations, and within that loops over each microbial generation. For each bacterial generation, we start by generating a new environmental pool based on the previous pool, and fitness based selection. It does this by first using the process_microbe_probs C++ function. This takes in the environmental pool from the previous generation, the host population, and the environmental condition. 2.3 Generating environmental pools. Microbial fitness is determined based on the fitness calculation based on each microbes optima and the environmental condition. We then multiple the relative abundance and the fitness to the give the initial sampling probability for microbes in the environment. This determines the fitness based sampling for the environment, we then determine the relative abundance of each microbe in the fixed environment, and the host populations. Each microbes abundance is then multipled by its relative contribution to give its sampling probability. For example, if hosts contribute 2% to the environment each generation, we would determine the relative abundance of microbes in the combined host population, and multiply that by 0.02 - the resulting values are the sampling probabilities for that microbe from the host. Next we would do the same for the fixed environment, so let’s say it’s 5% from the fixed environment - it would be relative abundance multiplied by 0.05. Finally we now have 93% that is determined by the previous generation and fitness. So we would multiply the fitness based sampling probabilities by 0.93. We then sum all the sampling probabilities - and this gives us the ultimate sampling probability for that microbial generations environment. 2.4 Generating new microbiomes within a host generation With the environmental pool now generated, we can generate a new microbiome for the hosts. This occurs with the process_host_cpp function, which determines the relative abundance of microbes in the environment, and in each host. We then calculate the fitness of each microbe when inside a host based on the mean of the host trait and the environmental condition. For example, if the environmental condition is 0.2 and the host optima is 0 - then the ‘ideal’ microbe has a trait value of 0.1. In this paper, we set all host trait values to 0. Fitness is determined for each microbe, and we then undertake fitness based selection. First, some proportion (self_seeding) of the microbiome is retained from the previous generation, and the remainder is acquired from the environment. Thus we can again calculate relative abundances in the host and environment, multiply these by either the self_seeding proportion or 1-self_seeding. These values are then multipled by the fitness values for each microbe to give us a fitness adjusted sampling probability. Once again, we then used multinomial sampling to generate a new microbiome. 2.5 Generating new hosts After some determined number of microbial generations has passed, hosts can reproduce. These hosts are determined based on fitness. To do this, we calculate a ‘composite’ trait value for each host - which is the weighted mean trait values of their microbes. Therefore, the hosts innate trait value does not effect its fitness directly, but rather by adjusting its microbiome. We can calculate the mean microbial trait value for each host - and then based on the distance between the environmental condition and the composite trait value we can determine the fitness. The fitness is then used as a sampling probability for hosts, where we sample hosts to reproduce WITH replacement based on their fitness until we have a full population of hosts. We then generate the new generation of hosts based on their parental microbiome. The parental microbiome is determined using the Create_OffSpring_Pop_cpp function discussed above. ## Clarify here how to save different elements of the data lapply_wrapper_CPP&lt;-function(XY, HostPopulation, N_Microbes, envpoolsize, env_pool,fixed_envpool,generations,per_host_bac_gens,self_seed_prop, selection_parameter_hosts,selection_parameter_microbes,host_trait_list,N_Species,traitpool_microbes, generation_data_file,selection_parameter_env,env_cond_val, microbiome_importances,host_microbe_optima,mutation_rate,mutation_sd,print_currentgen,weighting){ # profvis({ #Note: selection_parameter_hosts can be used to turn on, and adjust intensity of HS - when zero, host selection is off. #Similarly when selection_parameter_microbes is 0, we are using a neutral model, regardless of the given value of SelectionType. temp_list &lt;- list() print(paste(&quot;Current X Value is&quot;, XY[1], &quot;Current EnvCon value is&quot;, XY[2])) gen_data&lt;-list() microbe_names&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) env_used &lt;- NULL if(!nrow(env_cond_val) == generations){ print(&quot;env_cond_val should be a matrix of the same length as the number of generations you are simulating&quot;) stop() } init_microbial_fitness&lt;-matrix(NA,nrow = length(traitpool_microbes),ncol=length(host_microbe_optima)) for(i in 1:ncol(init_microbial_fitness)){ init_microbial_fitness[,i] &lt;- fitness_func_bacgen(selection_parameter = selection_parameter_microbes, optima1 = host_microbe_optima[i], optima2 = env_cond_val[1,1],trait = traitpool_microbes,weighting=weighting) } init_microbial_fitness&lt;-init_microbial_fitness[HostPopulation&gt;0] init_microbial_fitness&lt;-weighted.mean(x = init_microbial_fitness,w = HostPopulation) init_host_fitness&lt;-vector() for(i in 1:ncol(HostPopulation)){ mean_microbial_trait_val&lt;- sum(traitpool_microbes * HostPopulation[,i])/N_Microbes composite_host_trait&lt;-((mean_microbial_trait_val * microbiome_importances[i]) + (host_microbe_optima[i] * (1-microbiome_importances[i]))) hostfitness&lt;-fitness_func(selection_parameter = selection_parameter_hosts, trait = composite_host_trait,optima = env_cond_val[1,1]) init_host_fitness[i]&lt;-hostfitness } if(!ncol(env_cond_val)==per_host_bac_gens){ print(&quot;Number of columns in env_conditions should be the number of bacterial generations&quot;) stop() } if(is.na(self_seed_prop)){ print(&quot;Self seeding proportion is NA, please correct&quot;) } for (generation in 1:generations) { if(generation ==1){ env_used&lt;-fixed_envpool } env_cond_val_used&lt;-as.vector(env_cond_val[generation,]) for(bacgen in 1:per_host_bac_gens){ if(XY[2] + XY[3] &gt; 1) { print(&quot;The contribution of the fixed environment (Y) and the the autocthonous environment (var_env_con) is greater than 1, please correct this &quot;) stop() } gen_env_cond&lt;-env_cond_val_used[bacgen] env_used&lt;-process_microbe_probs(env_cond_val = gen_env_cond, fixed_envpool = fixed_envpool, HostPopulation = HostPopulation, N_Microbes = N_Microbes, envpoolsize = envpoolsize, selection_parameter_env = selection_parameter_env, XY = XY, traitpool_microbes = traitpool_microbes,env_used = env_used ) env_fits&lt;-weighted.mean(x = env_used[,3],w = env_used[,8]) env_used&lt;-env_used[,8] names(env_used)&lt;-names(fixed_envpool)#rownames(microbe_probs) if(bacgen &gt;1){ HostPopulation&lt;-process_host_cpp(HostPopulation = HostPopulation, selection_parameter_microbes = selection_parameter_microbes, host_microbe_optima = host_microbe_optima , env_condition = env_cond_val_used[bacgen], traitpool_microbes = traitpool_microbes, N_Microbes = N_Microbes, self_seed_prop = self_seed_prop,env_used = env_used,weighting = weighting)} else { HostPopulation&lt;-HostPopulation } } #Now we&#39;ve created our new environments, we now need to choose which members of a population reproduce # We can do this either neutrally (i.e., random chance) OR we can do this based on the fitness of a host based on what is provided by its microbiome host_fitnessvector&lt;-numeric() host_fitnessvector &lt;- calculate_host_fitness_cpp(as.matrix(HostPopulation), traitpool_microbes, microbiome_importances, host_microbe_optima, selection_parameter_hosts, env_cond_val_used[per_host_bac_gens]) nomicrobiomehost_fitnessvector&lt;-numeric() nomicrobiomehost_fitnessvector &lt;- calculate_host_fitness_cpp(as.matrix(HostPopulation), traitpool_microbes,rep(0,length(microbiome_importances)), host_microbe_optima, selection_parameter_hosts, env_cond_val_used[per_host_bac_gens]) hostfitness_abs&lt;-host_fitnessvector host_fitnessvector&lt;-host_fitnessvector#/mean(host_fitnessvector) HostPopulationInt&lt;-sample(colnames(HostPopulation),ncol(HostPopulation),replace = T,prob = host_fitnessvector) host_microbe_optima_prevgen&lt;-host_microbe_optima HostPopulation&lt;-HostPopulation[ , HostPopulationInt] host_microbe_optima&lt;-host_microbe_optima[HostPopulationInt] microbiome_importances&lt;-microbiome_importances[HostPopulationInt] mean_microbe_traitval&lt;-mean(apply(HostPopulation,MARGIN = 2,FUN=function(x){weighted.mean(traitpool_microbes,x)})) var_microbe_traitval&lt;-var(apply(HostPopulation,MARGIN = 2,FUN=function(x){weighted.mean(traitpool_microbes,x)})) if(mutation_rate&gt;0){ host_microbe_optima &lt;- mutate_trait(host_microbe_optima, mutation_rate, mutation_sd) } colnames(HostPopulation)&lt;-paste(&quot;Host&quot;,1:ncol(HostPopulation),sep=&quot;_&quot;) names(host_microbe_optima)&lt;-paste(&quot;Host&quot;,1:ncol(HostPopulation),sep=&quot;_&quot;) names(microbiome_importances)&lt;-paste(&quot;Host&quot;,1:ncol(HostPopulation),sep=&quot;_&quot;) if(print_currentgen==T){print(paste(&quot;Current Generation is&quot;, generation))} new_gen &lt;- Create_OffSpring_Pop_cpp(host_pop = HostPopulation, n_micro = N_Microbes, env_pool = env_used, envpoolsize = envpoolsize, X = XY[1], fixed_envpool = fixed_envpool, microbe_trait_list=traitpool_microbes, selection_parameter_microbes=selection_parameter_microbes, selection_parameter_hosts = selection_parameter_hosts, host_microbe_optima=host_microbe_optima, N_Species=N_Species, env_condition=env_cond_val_used[per_host_bac_gens], weighting=weighting) HostPopulation &lt;- new_gen$Child BrayDiv&lt;-vegdist(t(HostPopulation),method=&quot;bray&quot;) div_pergen&lt;-diversity(t(new_gen$Child)) richness&lt;-specnumber(t(new_gen$Child)) new_gen$HostFitness_Abs&lt;-(hostfitness_abs) new_gen$nomicrobiomehost_fitnessvector&lt;-nomicrobiomehost_fitnessvector new_gen$BrayDiv&lt;-BrayDiv new_gen$HostMicrobeOptima&lt;-host_microbe_optima_prevgen gen_data[[generation]]&lt;-list(div_pergen,new_gen$HostFitness_Abs,new_gen$microbefitness,env_used, env_fits,new_gen$HostMicrobeOptima,new_gen$nomicrobiomehost_fitnessvector,new_gen$microbe_samplingprob, microbiome_importances,new_gen$BrayDiv,mean_microbe_traitval,richness,var_microbe_traitval) names(gen_data[[generation]])&lt;-c(&quot;Diversity&quot;,&quot;HostFitness&quot;,&quot;MicrobeFitness&quot;,&quot;env_used&quot;,&quot;env_fits&quot; ,&quot;HostMicrobeOptima&quot;,&quot;nomicrobiomehost_fitnessvector&quot;, &quot;microbe_samplingprob&quot;,&quot;microbiome_importances&quot;,&quot;BrayDiv&quot;,&quot;mean_microbe_traitval&quot;,&quot;richness&quot;,&quot;var_microbe_traitval&quot;)#,&quot;HostPrefOptima&quot;,&quot;HostMicrobeOptima&quot;) } new_gen$GenData&lt;-gen_data new_gen$init_host_fitness&lt;-init_host_fitness new_gen$init_microbe_fitness&lt;-init_microbial_fitness new_gen$traitpool&lt;-traitpool_microbes temp_list[[paste0(&quot;X&quot;, XY[1], &quot;_Y&quot;, XY[2],&quot;_EnvCont&quot;,XY[3],&quot;_HostSel&quot;,XY[4],&quot;_MicrobeSel&quot;,XY[5])]] &lt;- new_gen temp_list } 2.6 Unused functions and capacities Because we intend to use this simulation framework for a range of studies, we have intentionally developed it with a lot of unused functions and capacities. For example, we include the “mutate_trait” value, and we allow for host traits to be variable. We do not utilize these here. 2.7 Running a simulation library(readr) library(reshape2) library(Rcpp) library(vegan) #library(flair) library(parallel) library(dplyr) library(ggplot2) calc_rich&lt;-function(population){ population[population&gt;0]&lt;-T colSums(population) } fast_mean &lt;- function(x) { x&lt;-x[!is.na(x)] sum(x) / length(x) } calc_div&lt;-function(population){ relabund&lt;-population/rowSums(population) - rowSums(relabund* log(relabund)) } fitness_func &lt;- function(selection_parameter, optima, trait) { q = exp(((trait - optima)^2) / -selection_parameter) q } fitness_func_bacgen&lt;-function(selection_parameter, optima1, optima2, trait, weighting) { meanval = (weighting * optima1) + ((1-weighting)*optima2) q = exp(((trait - meanval)^2) / -selection_parameter) return(q) } mutate_trait &lt;- function(trait, mutation_rate, mutation_sd) { mutated_trait &lt;- trait #+ rnorm(length(trait), mean = 0, sd = mutation_sd) mutate_mask &lt;- runif(length(trait)) &lt; mutation_rate mutated_trait[mutate_mask] &lt;- rnorm(sum(mutate_mask), mean = mutated_trait[mutate_mask], sd = mutation_sd) mutated_trait } Rcpp::sourceCpp(&#39;./calccpp_fit.cpp&#39;) sourceCpp(&quot;./withingen_process.cpp&quot;) sourceCpp(&quot;./env_production_withingen.cpp&quot;) knitr::opts_chunk$set(echo = TRUE) In our code we retain a lot information such as diversity, phenotypes/composite trait values, betadiversity, fitnesses, etc. It is better to calculate these as the simulation progresses rather than retaining every single generations data - because it is a lot of data that has to be saved and stored. We will start by generating an environmental matrix. This should be as many rows as you have host generations, and as many columns as you have microbial generations. In our paper, we generate environmental conditions for host generations, and interpolate between them smoothly for microbial generations, as seen in the code below. I will use an example environment here for white noise, similar to what is presented in our paper - the actual code for our environmental conditions is elsewhere in this repository. Below we present two plots - the first is at the scale of microbial generations based on 10 microbial generations per host generation. Hence it has 1,500 values - and is the result of smoothly interpolating between the environmental values at the host time scale (150 generations, the second plot). N_HostGens=150 start &lt;- seq(0.1, 0.1, length.out = N_HostGens*0.2) mid &lt;- seq(0.1, 0.3, length.out = N_HostGens*0.8) lowac_incvar&lt;-sapply(c(start,mid)*2.8, function(x){rnorm(1,0,x)}) expand_vector&lt;-function(vector, N) { expanded_vector &lt;- numeric() for (i in 1:(length(vector) - 1)) { expanded_vector &lt;- c(expanded_vector, vector[i], seq(vector[i], vector[i + 1], length.out = N)) } return(expanded_vector[1:(N*150)]) } env_vec&lt;-expand_vector(lowac_incvar,10) new_mat &lt;- matrix(env_vec,nrow = 150,ncol = 10,byrow = T) par(mfrow=c(1,2)) plot(env_vec,xlim=c(0,1500),ylab=&quot;Environmental Condition&quot;,xlab=&quot;Time point&quot;) plot(new_mat[,1],xlim=c(0,150),ylab=&quot;Environmental Condition&quot;,xlab=&quot;Host Generation&quot;) Now we can run a simulation: Host_PopSize= 100 MicrobePopSize=10^6 EnvPoolSize=10^8 N_Species =200 InitPopulation&lt;-matrix(nrow = N_Species, ncol=Host_PopSize) InitPopulation&lt;-apply(InitPopulation,MARGIN=2,FUN=function(x){ rmultinom(n=1,size = MicrobePopSize, prob =rep(1/N_Species,N_Species)) }) rownames(InitPopulation)&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) colnames(InitPopulation)&lt;-paste(&quot;Host&quot;,1:Host_PopSize,sep=&quot;_&quot;) EnvPool&lt;-rep(EnvPoolSize/N_Species,N_Species) names(EnvPool)&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) fixed_envpool&lt;-EnvPool rnames&lt;-paste(&quot;Host&quot;,1:Host_PopSize,sep=&quot;_&quot;) rnames&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) traitpool_microbes&lt;-runif(N_Species,-2.5,2.5) names(traitpool_microbes)&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) mnames&lt;-colnames(InitPopulation) host_microbe_optima&lt;-rep(0,Host_PopSize) names(host_microbe_optima)&lt;-mnames microbiome_importances&lt;-rep(1,Host_PopSize)#runif(Host_PopSize,0,1) names(microbiome_importances)&lt;-mnames combination=c( 0.5, #Proportion of vertical inheritance 0.05, #Proportion of host &#39;shedding&#39; to the environment. 0.8) #Proportion of environmental pool which contributes to subsequent environmental pool. simulation_test &lt;- lapply_wrapper_CPP( XY = combination, HostPopulation = InitPopulation, N_Microbes = MicrobePopSize, envpoolsize = EnvPoolSize, env_pool = EnvPool, generations = nrow(new_mat), fixed_envpool = fixed_envpool, selection_parameter_hosts = 1, selection_parameter_microbes = 1, traitpool_microbes = traitpool_microbes, host_microbe_optima = host_microbe_optima, selection_parameter_env = 1, env_cond_val = new_mat, N_Species = N_Species, microbiome_importances = microbiome_importances, per_host_bac_gens = ncol(new_mat), self_seed_prop = 0.98, generation_data_file = NA, mutation_rate = 0.0, mutation_sd = 0.0, print_currentgen = F, weighting=0.5 ) ## [1] &quot;Current X Value is 0.5 Current EnvCon value is 0.05&quot; We’ve done a simulation above, so here I will just make a demonstration figure. Most of the useful data is stored within “GenData” - which contains data from every host generation. MicrobialFitnesses&lt;-vector() HostFitnesses&lt;-vector() for(i in seq_along(simulation_test[[1]]$GenData)){ MicrobialFitnesses[i]&lt;- mean(simulation_test[[1]]$GenData[[i]]$MicrobeFitness) HostFitnesses[i]&lt;- mean(simulation_test[[1]]$GenData[[i]]$HostFitness) } par(mfrow=c(1,2)) plot(HostFitnesses,xlab=&quot;Generation&quot;,ylab=&quot;Host Fitness&quot;) plot(MicrobialFitnesses,xlab=&quot;Generation&quot;,ylab=&quot;Microbial Fitness&quot;) "],["paper-1---effective-vertical-inheritance.html", "3 Paper 1 - Effective vertical inheritance 3.1 Running an effective VI simulation", " 3 Paper 1 - Effective vertical inheritance pre.r + pre.r { margin-top: -1em; border-top-left-radius: 0; border-top-right-radius: 0; border-top: none; } .badCode { background-color: #c9fffb; color:black; } As we discuss in our paper, we include a comparison of vertical inheritance levels. We term ‘effective’ vertical inheritance as the proportion of parental microbes which are inherited at the point at which a host reproduces. For example, if a host inherits 99% of its microbes from its parents - but then lives for 100 microbial generations, the effective vertical inheritance will be lower than for 50 microbial generations due to acquistion of microbes from the environment, and the loss of parental microbes. We address this by running some bespoke simulations where at the 500th host generation, we label parental microbes and track their abundance over the course of a host generation. We do this for each environmental condition. This works in ‘janky’ way initializing the simulation with 400 ‘species’ slots, of which only 200 are occupied. At generation 498 we copy the parental microbes into the additional 200 slots which are called “VI_Spec_X” etc, and then we track the abundance of these over the course of the simulation in the subsequent generation. To properly test this - we first calculate the effective vertical inheritance, and then run our simulations as normal except we set microbial generation counts to 1, and we substitute the vertical inheritance values for the effective vertical inheritance values obtained for a generation count of interest. For example, in the following simulation we are interested in comparing the fitnesses of hosts with 50 microbial generations - while account for effective vertical inheritance. To address this, we will run a effective vertical inheritance simulation with 50 generations. We then determine what the effective vertical inheritance is, and then use that value as the effective vertical inheritance in a normal simulation where microbial generation count is 1. This allows to see if the benefits to host from microbial generation counts is the result of optimized vertical inheritance (in which case, fitnesses should be equivalent in both simulations) - or whether generation count itself is beneficial. Most of the code is relatively unchanged from normal. The key difference is the use of a modified create_offspring_loop.cpp function. knitr::opts_chunk$set(echo = TRUE) library(dplyr) library(readr) library(reshape2) library(Rcpp) library(vegan) library(parallel) library(ggplot2) #library(tidyverse) calc_rich&lt;-function(population){ population[population&gt;0]&lt;-T colSums(population,na.rm=T) } fast_mean &lt;- function(x) { x&lt;-x[!is.na(x)] sum(x) / length(x) } calc_div&lt;-function(population){ relabund&lt;-population/rowSums(population,na.rm=T) - rowSums(relabund* log(relabund),na.rm=T) } fitness_func &lt;- function(selection_parameter, optima, trait) { q = exp(((trait - optima)^2) / -selection_parameter) q } fitness_func_bacgen&lt;-function(selection_parameter, optima1, optima2, trait, weighting) { meanval = (weighting * optima1) + ((1-weighting)*optima2) q = exp(((trait - meanval)^2) / -selection_parameter) return(q) } mutate_trait &lt;- function(trait, mutation_rate, mutation_sd) { mutated_trait &lt;- trait #+ rnorm(length(trait), mean = 0, sd = mutation_sd) mutate_mask &lt;- runif(length(trait)) &lt; mutation_rate mutated_trait[mutate_mask] &lt;- rnorm(sum(mutate_mask), mean = mutated_trait[mutate_mask], sd = mutation_sd) mutated_trait } Rcpp::sourceCpp(&#39;./evi_code/calccpp_fit.cpp&#39;) sourceCpp(&quot;./evi_code/withingen_process.cpp&quot;) sourceCpp(&quot;./evi_code/env_production_withingen.cpp&quot;) Rcpp::sourceCpp(&quot;./evi_code/create_offspring_loop_vi.cpp&quot;) Below is the R code to run the effective vertical inheritance work, with blue highlighted code indicating that the code is bespoke for this section. Create_OffSpring_Pop_cpp&lt;-function(host_pop,n_micro,env_pool,envpoolsize,X,fixed_envpool, selection_parameter_microbes,selection_parameter_hosts,microbe_trait_list, host_microbe_optima, N_Species,env_condition,weighting,generation){ microbe_names&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) ENV_sampling_probability&lt;-(env_pool)/envpoolsize #Calculate initial sampling probability based on environmental relative abundance names(ENV_sampling_probability)&lt;-names(env_pool) if(generation == 498){ offspring_population&lt;-offspring_loopfunc_vi(host_pop = host_pop,ENV_sampling_probability = ENV_sampling_probability, host_microbe_optima = host_microbe_optima, X = X, selection_parameter_microbes = selection_parameter_microbes, env_condition = env_condition,microbe_trait_list = microbe_trait_list, n_micro = n_micro,microbe_names = microbe_names,weighting=weighting)#, } else{ offspring_population&lt;-offspring_loopfunc(host_pop = host_pop,ENV_sampling_probability = ENV_sampling_probability, host_microbe_optima = host_microbe_optima, X = X, selection_parameter_microbes = selection_parameter_microbes, env_condition = env_condition,microbe_trait_list = microbe_trait_list, n_micro = n_micro,microbe_names = microbe_names,weighting=weighting)#, # fitness_microbes = fitness_microbes,weighted_samplingprob = weighted_samplingprob) offspring_population&lt;-list(offspring_population$host_pop,env_pool,microbe_trait_list,offspring_population$fitness_microbes, offspring_population$weighted_samplingprob) } names(offspring_population)&lt;-c(&quot;Child&quot;,&quot;microbefitness&quot;,&quot;microbe_samplingprob&quot;) offspring_population } lapply_wrapper_CPP&lt;-function(XY, HostPopulation, N_Microbes, envpoolsize, env_pool,fixed_envpool,generations,per_host_bac_gens,self_seed_prop, selection_parameter_hosts,selection_parameter_microbes,host_trait_list,N_Species,traitpool_microbes, generation_data_file,selection_parameter_env,env_cond_val, microbiome_importances,host_microbe_optima,mutation_rate,mutation_sd,print_currentgen,weighting,env_type,output_dir){ #Note: selection_parameter_hosts can be used to turn on, and adjust intensity of HS - when zero, host selection is off. #Similarly when selection_parameter_microbes is 0, we are using a neutral model, regardless of the given value of SelectionType. temp_list &lt;- list() print(paste(&quot;Current X Value is&quot;, XY[1], &quot;Current EnvCon value is&quot;, XY[2])) gen_data&lt;-list() microbe_names&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) env_used &lt;- NULL if(!nrow(env_cond_val) == generations){ print(&quot;env_cond_val should be a matrix of the same length as the number of generations you are simulating&quot;) stop() } init_microbial_fitness&lt;-matrix(NA,nrow = length(traitpool_microbes),ncol=length(host_microbe_optima)) for(i in 1:ncol(init_microbial_fitness)){ init_microbial_fitness[,i] &lt;- fitness_func_bacgen(selection_parameter = selection_parameter_microbes, optima1 = host_microbe_optima[i], optima2 = env_cond_val[1,1],trait = traitpool_microbes,weighting=weighting) } print(dim(init_microbial_fitness)) print(dim(HostPopulation)) # init_microbial_fitness&lt;-init_microbial_fitness[HostPopulation&gt;0] init_microbial_fitness&lt;-weighted.mean(x = init_microbial_fitness,w = HostPopulation) init_host_fitness&lt;-vector() for(i in 1:ncol(HostPopulation)){ mean_microbial_trait_val&lt;- sum(traitpool_microbes * HostPopulation[,i])/N_Microbes composite_host_trait&lt;-((mean_microbial_trait_val * microbiome_importances[i]) + (host_microbe_optima[i] * (1-microbiome_importances[i]))) hostfitness&lt;-fitness_func(selection_parameter = selection_parameter_hosts, trait = composite_host_trait,optima = env_cond_val[1,1]) init_host_fitness[i]&lt;-hostfitness } if(!ncol(env_cond_val)==per_host_bac_gens){ print(&quot;Number of columns in env_conditions should be the number of bacterial generations&quot;) stop() } if(is.na(self_seed_prop)){ print(&quot;Self seeding proportion is NA, please correct&quot;) } for (generation in 1:generations) { if(generation ==1){ env_used&lt;-fixed_envpool } env_cond_val_used&lt;-as.vector(env_cond_val[generation,]) vi_ests&lt;-matrix(NA,nrow = 400,ncol = 200) for(bacgen in 1:per_host_bac_gens){ if(XY[2] + XY[3] &gt; 1) { print(&quot;The contribution of the fixed environment (Y) and the the autocthonous environment (var_env_con) is greater than 1, please correct this &quot;) stop() } gen_env_cond&lt;-env_cond_val_used[bacgen] env_used&lt;-process_microbe_probs(env_cond_val = gen_env_cond, fixed_envpool = fixed_envpool, HostPopulation = HostPopulation, N_Microbes = N_Microbes, envpoolsize = envpoolsize, selection_parameter_env = selection_parameter_env, XY = XY, traitpool_microbes = traitpool_microbes,env_used = env_used ) env_fits&lt;-weighted.mean(x = env_used[,3],w = env_used[,8]) env_used&lt;-env_used[,8] names(env_used)&lt;-names(fixed_envpool)#rownames(microbe_probs) if(bacgen &gt;1){ HostPopulation&lt;-process_host_cpp(HostPopulation = HostPopulation, selection_parameter_microbes = selection_parameter_microbes, host_microbe_optima = host_microbe_optima , env_condition = env_cond_val_used[bacgen], traitpool_microbes = traitpool_microbes, N_Microbes = N_Microbes, self_seed_prop = self_seed_prop,env_used = env_used,weighting = weighting)} if(generation ==497){ write_rds(HostPopulation,paste(output_dir,&quot;X&quot;,env_type,XY[1],&quot;HostPopulation.RDS&quot;,sep=&quot;_&quot;)) } if(generation == 499){ vi_ests[,bacgen]&lt;-HostPopulation[,1] } } if(generation == 499){ write_rds(vi_ests,paste(output_dir,&quot;X&quot;,env_type,XY[1],&quot;vi_ests.RDS&quot;,sep=&quot;_&quot;)) } if(generation == 501){ return(NULL) } host_fitnessvector&lt;-numeric() host_fitnessvector &lt;- calculate_host_fitness_cpp(as.matrix(HostPopulation), traitpool_microbes, microbiome_importances, host_microbe_optima, selection_parameter_hosts, env_cond_val_used[per_host_bac_gens]) nomicrobiomehost_fitnessvector&lt;-numeric() nomicrobiomehost_fitnessvector &lt;- calculate_host_fitness_cpp(as.matrix(HostPopulation), traitpool_microbes,rep(0,length(microbiome_importances)), host_microbe_optima, selection_parameter_hosts, env_cond_val_used[per_host_bac_gens]) hostfitness_abs&lt;-host_fitnessvector host_fitnessvector&lt;-host_fitnessvector#/mean(host_fitnessvector) HostPopulationInt&lt;-sample(colnames(HostPopulation),ncol(HostPopulation),replace = T,prob = host_fitnessvector) host_microbe_optima_prevgen&lt;-host_microbe_optima HostPopulation&lt;-HostPopulation[ , HostPopulationInt] host_microbe_optima&lt;-host_microbe_optima[HostPopulationInt] microbiome_importances&lt;-microbiome_importances[HostPopulationInt] mean_microbe_traitval&lt;-mean(apply(HostPopulation,MARGIN = 2,FUN=function(x){weighted.mean(traitpool_microbes,x)})) if(mutation_rate&gt;0){ host_microbe_optima &lt;- mutate_trait(host_microbe_optima, mutation_rate, mutation_sd) } colnames(HostPopulation)&lt;-paste(&quot;Host&quot;,1:ncol(HostPopulation),sep=&quot;_&quot;) names(host_microbe_optima)&lt;-paste(&quot;Host&quot;,1:ncol(HostPopulation),sep=&quot;_&quot;) names(microbiome_importances)&lt;-paste(&quot;Host&quot;,1:ncol(HostPopulation),sep=&quot;_&quot;) if(print_currentgen==T){print(paste(&quot;Current Generation is&quot;, generation))} new_gen &lt;- Create_OffSpring_Pop_cpp(host_pop = HostPopulation, n_micro = N_Microbes, env_pool = env_used, envpoolsize = envpoolsize, X = XY[1], fixed_envpool = fixed_envpool, microbe_trait_list=traitpool_microbes, selection_parameter_microbes=selection_parameter_microbes, selection_parameter_hosts = selection_parameter_hosts, host_microbe_optima=host_microbe_optima, N_Species=N_Species, env_condition=env_cond_val_used[per_host_bac_gens], weighting=weighting, generation=generation) HostPopulation &lt;- new_gen$Child BrayDiv&lt;-vegdist(t(HostPopulation),method=&quot;bray&quot;) div_pergen&lt;-diversity(t(new_gen$Child)) richness&lt;-specnumber(t(new_gen$Child)) new_gen$HostFitness_Abs&lt;-(hostfitness_abs) new_gen$nomicrobiomehost_fitnessvector&lt;-nomicrobiomehost_fitnessvector new_gen$BrayDiv&lt;-BrayDiv new_gen$HostMicrobeOptima&lt;-host_microbe_optima_prevgen gen_data[[generation]]&lt;-list(div_pergen,new_gen$HostFitness_Abs,new_gen$microbefitness,env_used, env_fits,new_gen$HostMicrobeOptima,new_gen$nomicrobiomehost_fitnessvector,new_gen$microbe_samplingprob, microbiome_importances,new_gen$BrayDiv,mean_microbe_traitval,richness) names(gen_data[[generation]])&lt;-c(&quot;Diversity&quot;,&quot;HostFitness&quot;,&quot;MicrobeFitness&quot;,&quot;env_used&quot;,&quot;env_fits&quot; ,&quot;HostMicrobeOptima&quot;,&quot;nomicrobiomehost_fitnessvector&quot;, &quot;microbe_samplingprob&quot;,&quot;microbiome_importances&quot;,&quot;BrayDiv&quot;,&quot;mean_microbe_traitval&quot;,&quot;richness&quot;)#,&quot;HostPrefOptima&quot;,&quot;HostMicrobeOptima&quot;) } } 3.1 Running an effective VI simulation Host_PopSize= 100 MicrobePopSize=10^6 EnvPoolSize=10^8 N_Species =400 InitPopulation&lt;-matrix(nrow = 200, ncol=Host_PopSize) InitPopulation&lt;-apply(InitPopulation,MARGIN=2,FUN=function(x){ rmultinom(n=1,size = MicrobePopSize, prob =rep(1/200,200)) }) rownames(InitPopulation)&lt;-paste(&quot;Microbe&quot;,1:200,sep=&quot;_&quot;) colnames(InitPopulation)&lt;-paste(&quot;Host&quot;,1:Host_PopSize,sep=&quot;_&quot;) VI_InitPopulation&lt;-matrix(data=0,nrow = 200, ncol=Host_PopSize) rownames(VI_InitPopulation)&lt;-paste(&quot;VI_Microbe&quot;,1:200,sep=&quot;_&quot;) colnames(VI_InitPopulation)&lt;-paste(&quot;Host&quot;,1:Host_PopSize,sep=&quot;_&quot;) InitPopulation&lt;-rbind(InitPopulation,VI_InitPopulation) EnvPool&lt;-rep(EnvPoolSize/200,200) names(EnvPool)&lt;-paste(&quot;Microbe&quot;,1:200,sep=&quot;_&quot;) VI_EnvPool&lt;-rep(0,200) names(VI_EnvPool)&lt;-paste(&quot;VI_Microbe&quot;,1:200,sep=&quot;_&quot;) EnvPool&lt;-c(EnvPool,VI_EnvPool) fixed_envpool&lt;-EnvPool traitpool_microbes&lt;-runif(200,-1,1) traitpool_microbes&lt;-c(traitpool_microbes,traitpool_microbes) names(traitpool_microbes)&lt;-names(EnvPool) mnames&lt;-colnames(InitPopulation) host_microbe_optima&lt;-rep(0,Host_PopSize) names(host_microbe_optima)&lt;-mnames microbiome_importances&lt;-rep(1,Host_PopSize)#runif(Host_PopSize,0,1) names(microbiome_importances)&lt;-mnames N_HostGens=800 start &lt;- seq(0.1, 0.1, length.out = N_HostGens*0.2) mid &lt;- seq(0.1, 0.3, length.out = N_HostGens*0.8) lowac_incvar&lt;-sapply(c(start,mid)*2.8, function(x){rnorm(1,0,x)}) expand_vector&lt;-function(vector, N) { expanded_vector &lt;- numeric() for (i in 1:(length(vector) - 1)) { expanded_vector &lt;- c(expanded_vector, vector[i], seq(vector[i], vector[i + 1], length.out = N)) } return(expanded_vector[1:(N*800)]) } env_vec&lt;-expand_vector(lowac_incvar,10) new_mat &lt;- matrix(env_vec,nrow = 800,ncol = 10,byrow = T) combination=c( 0.5, #Proportion of vertical inheritance 0.05, #Proportion of host &#39;shedding&#39; to the environment. 0.8) #Proportion of environmental pool which contributes to subsequent environmental pool. envtype&lt;-as.character(&quot;DummyEnv&quot;) simulation_test &lt;- lapply_wrapper_CPP( XY = combination, HostPopulation = InitPopulation, N_Microbes = MicrobePopSize, envpoolsize = EnvPoolSize, env_pool = EnvPool, generations = nrow(new_mat), fixed_envpool = fixed_envpool, selection_parameter_hosts = 1, selection_parameter_microbes = 1, traitpool_microbes = traitpool_microbes, host_microbe_optima = host_microbe_optima, selection_parameter_env = 1, env_cond_val = new_mat, N_Species = N_Species, microbiome_importances = microbiome_importances, per_host_bac_gens = ncol(new_mat), self_seed_prop = 0.98, generation_data_file = NA, mutation_rate = 0.0, mutation_sd = 0.0, print_currentgen = F, weighting = 0.5, env_type=envtype, output_dir=&quot;&quot;) ## [1] &quot;Current X Value is 0.5 Current EnvCon value is 0.05&quot; ## [1] 400 100 ## [1] 400 100 We have now run a simulation where we have measured effective vertical inheritance. We can analysis this as follows: viests&lt;-list.files(pattern=&quot;*ests.RDS&quot;) viests&lt;-lapply(viests,read_rds) viests&lt;-lapply(viests,function(q){ colSums(q[201:400,1:10])/colSums(q[,1:10]) }) names(viests)&lt;-list.files(pattern=&quot;*ests.RDS&quot;) viests&lt;-do.call(&quot;rbind&quot;,viests) viests&lt;-reshape2::melt(viests) #viests&lt;-viests[complete.cases(viests),] viests$InitVert&lt;- gsub(&quot;.RDS&quot;,&quot;&quot;,viests$Var1) viests$InitVert&lt;- stringr::word(viests$InitVert,4,sep=&quot;_&quot;) #viests$InitVert&lt;-gsub(&quot;[^0-9.-]&quot;, &quot;&quot;, viests$InitVert) efi_relationship&lt;-ggplot(viests) + aes(x = Var2, y = value, colour = InitVert) + geom_line(linewidth=2) + scale_color_hue(direction = 1) + theme_minimal() + xlab(&quot;Microbial Generations within a host&quot;) + ylab(&quot;Proportion of Vertical Acquired Microbes remaining&quot;) #+ facet_wrap(~Environment) efi_relationship We can now see that at microbial generation 10 the effective vertical inheritance is approximately 0.38 - despite hosts initially obtaining 50% of their microbiome from their parent. "]]
