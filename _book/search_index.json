[["paper-1---joint-consideration-of-selection-and-microbial-generation-count-provides-unique-insights-into-evolutionary-and-ecological-dynamics-of-holobionts.html", "2 Paper 1 - Joint consideration of selection and microbial generation count provides unique insights into evolutionary and ecological dynamics of holobionts 2.1 Creating offspring function - create_offspring_loop.cpp 2.2 General simulation wrapper code 2.3 Generating environmental pools. 2.4 Generating new microbiomes within a host generation 2.5 Generating new hosts 2.6 Unused functions and capacities 2.7 Running a simulation", " 2 Paper 1 - Joint consideration of selection and microbial generation count provides unique insights into evolutionary and ecological dynamics of holobionts Here I provide a general outline for the framework presented in our paper. 2.1 Creating offspring function - create_offspring_loop.cpp Here we implementing the create offspring function, this essentially takes in a host population and generates the offspring for the subsequent host generation. We determine the individuals which reproduce elsewhere in the code, this just takes those parents and produces offspring children. It functions by calculating the relative abundance of each microbe in the parent, the relative abundance in the environment, and the combines the abundances based on the relative contribution of parent vs environment to the child. The fitness of each microbial taxa in the host is determined and the product of the fitness and the relative abundance determines the sampling probability of that microbe into the offspring. The microbes are then sampled multinomially to produce the offsprings microbiome. We implement this as a C++ R code, because this is executed many many times and it is very slow to run it normally in R. Rcpp::sourceCpp(&quot;./create_offspring_loop.cpp&quot;) Create_OffSpring_Pop_cpp&lt;-function(host_pop,n_micro,env_pool,envpoolsize,X,fixed_envpool, selection_parameter_microbes,selection_parameter_hosts,microbe_trait_list, host_microbe_optima, N_Species,env_condition){ microbe_names&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) ENV_sampling_probability&lt;-(env_pool)/envpoolsize #Calculate initial sampling probability based on environmental relative abundance names(ENV_sampling_probability)&lt;-names(env_pool) offspring_population&lt;-offspring_loopfunc(host_pop = host_pop,ENV_sampling_probability = ENV_sampling_probability, host_microbe_optima = host_microbe_optima, X = X, selection_parameter_microbes = selection_parameter_microbes, env_condition = env_condition,microbe_trait_list = microbe_trait_list, n_micro = n_micro,microbe_names = microbe_names) offspring_population&lt;-list(offspring_population$host_pop,env_pool,microbe_trait_list,offspring_population$fitness_microbes, offspring_population$weighted_samplingprob) names(offspring_population)&lt;-c(&quot;Child&quot;,&quot;Env&quot;,&quot;microbe_trait_list&quot;,&quot;microbefitness&quot;,&quot;microbe_samplingprob&quot;) offspring_population } 2.2 General simulation wrapper code This code first works by calculating initial fitness values so we have them recorded. It loops over N generations, and within that loops over each microbial generation. For each bacterial generation, we start by generating a new environmental pool based on the previous pool, and fitness based selection. It does this by first using the process_microbe_probs C++ function. This takes in the environmental pool from the previous generation, the host population, and the environmental condition. 2.3 Generating environmental pools. Microbial fitness is determined based on the fitness calculation based on each microbes optima and the environmental condition. We then multiple the relative abundance and the fitness to the give the initial sampling probability for microbes in the environment. This determines the fitness based sampling for the environment, we then determine the relative abundance of each microbe in the fixed environment, and the host populations. Each microbes abundance is then multipled by its relative contribution to give its sampling probability. For example, if hosts contribute 2% to the environment each generation, we would determine the relative abundance of microbes in the combined host population, and multiply that by 0.02 - the resulting values are the sampling probabilities for that microbe from the host. Next we would do the same for the fixed environment, so let’s say it’s 5% from the fixed environment - it would be relative abundance multiplied by 0.05. Finally we now have 93% that is determined by the previous generation and fitness. So we would multiply the fitness based sampling probabilities by 0.93. We then sum all the sampling probabilities - and this gives us the ultimate sampling probability for that microbial generations environment. 2.4 Generating new microbiomes within a host generation With the environmental pool now generated, we can generate a new microbiome for the hosts. This occurs with the process_host_cpp function, which determines the relative abundance of microbes in the environment, and in each host. We then calculate the fitness of each microbe when inside a host based on the mean of the host trait and the environmental condition. For example, if the environmental condition is 0.2 and the host optima is 0 - then the ‘ideal’ microbe has a trait value of 0.1. In this paper, we set all host trait values to 0. Fitness is determined for each microbe, and we then undertake fitness based selection. First, some proportion (self_seeding) of the microbiome is retained from the previous generation, and the remainder is acquired from the environment. Thus we can again calculate relative abundances in the host and environment, multiply these by either the self_seeding proportion or 1-self_seeding. These values are then multipled by the fitness values for each microbe to give us a fitness adjusted sampling probability. Once again, we then used multinomial sampling to generate a new microbiome. 2.5 Generating new hosts After some determined number of microbial generations has passed, hosts can reproduce. These hosts are determined based on fitness. To do this, we calculate a ‘composite’ trait value for each host - which is the weighted mean trait values of their microbes. Therefore, the hosts innate trait value does not effect its fitness directly, but rather by adjusting its microbiome. We can calculate the mean microbial trait value for each host - and then based on the distance between the environmental condition and the composite trait value we can determine the fitness. The fitness is then used as a sampling probability for hosts, where we sample hosts to reproduce WITH replacement based on their fitness until we have a full population of hosts. We then generate the new generation of hosts based on their parental microbiome. The parental microbiome is determined using the Create_OffSpring_Pop_cpp function discussed above. ## Clarify here how to save different elements of the data lapply_wrapper_CPP&lt;-function(XY, HostPopulation, N_Microbes, envpoolsize, env_pool,fixed_envpool,generations,per_host_bac_gens,self_seed_prop, selection_parameter_hosts,selection_parameter_microbes,host_trait_list,N_Species,traitpool_microbes, generation_data_file,selection_parameter_env,env_cond_val, microbiome_importances,host_microbe_optima,mutation_rate,mutation_sd,print_currentgen){ #Note: selection_parameter_hosts can be used to turn on, and adjust intensity of HS - when zero, host selection is off. #Similarly when selection_parameter_microbes is 0, we are using a neutral model, regardless of the given value of SelectionType. temp_list &lt;- list() print(paste(&quot;Current X Value is&quot;, XY[1], &quot;Current EnvCon value is&quot;, XY[2])) gen_data&lt;-list() microbe_names&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) env_used &lt;- NULL if(!nrow(env_cond_val) == generations){ print(&quot;env_cond_val should be a matrix of the same length as the number of generations you are simulating&quot;) stop() } init_microbial_fitness&lt;-matrix(NA,nrow = length(traitpool_microbes),ncol=length(host_microbe_optima)) for(i in 1:ncol(init_microbial_fitness)){ init_microbial_fitness[,i] &lt;- fitness_func_bacgen(selection_parameter = selection_parameter_microbes, optima1 = host_microbe_optima[i], optima2 = env_cond_val[1,1],trait = traitpool_microbes) } init_microbial_fitness&lt;-init_microbial_fitness[HostPopulation&gt;0] init_microbial_fitness&lt;-weighted.mean(x = init_microbial_fitness,w = HostPopulation) init_host_fitness&lt;-vector() for(i in 1:ncol(HostPopulation)){ mean_microbial_trait_val&lt;- sum(traitpool_microbes * HostPopulation[,i])/N_Microbes composite_host_trait&lt;-((mean_microbial_trait_val * microbiome_importances[i]) + (host_microbe_optima[i] * (1-microbiome_importances[i]))) hostfitness&lt;-fitness_func(selection_parameter = selection_parameter_hosts, trait = composite_host_trait,optima = env_cond_val[1,1]) init_host_fitness[i]&lt;-hostfitness } if(!ncol(env_cond_val)==per_host_bac_gens){ print(&quot;Number of columns in env_conditions should be the number of bacterial generations&quot;) stop() } if(is.na(self_seed_prop)){ print(&quot;Self seeding proportion is NA, please correct&quot;) } for (generation in 1:generations) { if(generation ==1){ env_used&lt;-fixed_envpool } if(per_host_bac_gens == 1){ self_seed_prop=1 } env_cond_val_used&lt;-as.vector(env_cond_val[generation,]) for(bacgen in 1:per_host_bac_gens){ if(XY[2] + XY[3] &gt; 1) { print(&quot;The contribution of the fixed environment (Y) and the the autocthonous environment (var_env_con) is greater than 1, please correct this &quot;) stop() } gen_env_cond&lt;-env_cond_val_used[bacgen] env_used&lt;-process_microbe_probs(env_cond_val = gen_env_cond, fixed_envpool = fixed_envpool, HostPopulation = HostPopulation, N_Microbes = N_Microbes, envpoolsize = envpoolsize, selection_parameter_env = selection_parameter_env, XY = XY, traitpool_microbes = traitpool_microbes,env_used = env_used )#[,8] env_fits&lt;-weighted.mean(x = env_used[,3],w = env_used[,8]) env_used&lt;-env_used[,8] names(env_used)&lt;-names(fixed_envpool) HostPopulation&lt;-process_host_cpp(HostPopulation = HostPopulation, selection_parameter_microbes = selection_parameter_microbes, host_microbe_optima = host_microbe_optima , env_condition = env_cond_val_used[bacgen], traitpool_microbes = traitpool_microbes, N_Microbes = N_Microbes, self_seed_prop = self_seed_prop,env_used = env_used) } #Now we&#39;ve created our new environments, we now need to choose which members of a population reproduce # We can do this either neutrally (i.e., random chance) OR we can do this based on the fitness of a host based on what is provided by its microbiome host_fitnessvector&lt;-numeric() host_fitnessvector &lt;- calculate_host_fitness_cpp(as.matrix(HostPopulation), traitpool_microbes, microbiome_importances, host_microbe_optima, selection_parameter_hosts, env_cond_val_used[per_host_bac_gens]) nomicrobiomehost_fitnessvector&lt;-numeric() nomicrobiomehost_fitnessvector &lt;- calculate_host_fitness_cpp(as.matrix(HostPopulation), traitpool_microbes,rep(0,length(microbiome_importances)), host_microbe_optima, selection_parameter_hosts, env_cond_val_used[per_host_bac_gens]) hostfitness_abs&lt;-host_fitnessvector host_fitnessvector&lt;-host_fitnessvector#/mean(host_fitnessvector) HostPopulationInt&lt;-sample(colnames(HostPopulation),ncol(HostPopulation),replace = T,prob = host_fitnessvector) host_microbe_optima_prevgen&lt;-host_microbe_optima HostPopulation&lt;-HostPopulation[ , HostPopulationInt] host_microbe_optima&lt;-host_microbe_optima[HostPopulationInt] microbiome_importances&lt;-microbiome_importances[HostPopulationInt] if(mutation_rate&gt;0){ host_microbe_optima &lt;- mutate_trait(host_microbe_optima, mutation_rate, mutation_sd) } colnames(HostPopulation)&lt;-paste(&quot;Host&quot;,1:ncol(HostPopulation),sep=&quot;_&quot;) names(host_microbe_optima)&lt;-paste(&quot;Host&quot;,1:ncol(HostPopulation),sep=&quot;_&quot;) names(microbiome_importances)&lt;-paste(&quot;Host&quot;,1:ncol(HostPopulation),sep=&quot;_&quot;) if(print_currentgen==T){print(paste(&quot;Current Generation is&quot;, generation))} new_gen &lt;- Create_OffSpring_Pop_cpp(host_pop = HostPopulation, n_micro = N_Microbes, env_pool = env_used, envpoolsize = envpoolsize, X = XY[1], fixed_envpool = fixed_envpool, microbe_trait_list=traitpool_microbes, selection_parameter_microbes=selection_parameter_microbes, selection_parameter_hosts = selection_parameter_hosts, host_microbe_optima=host_microbe_optima, N_Species=N_Species, env_condition=env_cond_val_used[per_host_bac_gens]) # print(&quot;Issue here&quot;) HostPopulation &lt;- new_gen$Child BrayDiv&lt;-vegdist(t(HostPopulation),method=&quot;bray&quot;) div_pergen&lt;-calc_div(t(new_gen$Child))/log(calc_rich(new_gen$Child)) new_gen$HostFitness_Abs&lt;-(hostfitness_abs) new_gen$nomicrobiomehost_fitnessvector&lt;-nomicrobiomehost_fitnessvector new_gen$BrayDiv&lt;-BrayDiv new_gen$HostMicrobeOptima&lt;-host_microbe_optima_prevgen gen_data[[generation]]&lt;-list(div_pergen,new_gen$HostFitness_Abs,new_gen$microbefitness,env_used, env_fits,new_gen$HostMicrobeOptima,new_gen$nomicrobiomehost_fitnessvector,new_gen$microbe_samplingprob, microbiome_importances,new_gen$BrayDiv) names(gen_data[[generation]])&lt;-c(&quot;Diversity&quot;,&quot;HostFitness&quot;,&quot;MicrobeFitness&quot;,&quot;env_used&quot;,&quot;env_fits&quot; ,&quot;HostMicrobeOptima&quot;,&quot;nomicrobiomehost_fitnessvector&quot;, &quot;microbe_samplingprob&quot;,&quot;microbiome_importances&quot;,&quot;BrayDiv&quot;)#,&quot;HostPrefOptima&quot;,&quot;HostMicrobeOptima&quot;) } new_gen$GenData&lt;-gen_data new_gen$init_host_fitness&lt;-init_host_fitness new_gen$init_microbe_fitness&lt;-init_microbial_fitness temp_list[[paste0(&quot;X&quot;, XY[1], &quot;_Y&quot;, XY[2],&quot;_EnvCont&quot;,XY[3],&quot;_HostSel&quot;,XY[4],&quot;_MicrobeSel&quot;,XY[5])]] &lt;- new_gen temp_list } 2.6 Unused functions and capacities Because we intend to use this simulation framework for a range of studies, we have intentionally developed it with a lot of unused functions and capacities. For example, we include the “mutate_trait” value, and we allow for host traits to be variable. We do not utilize these here. 2.7 Running a simulation library(readr) library(reshape2) library(Rcpp) library(vegan) ## Loading required package: permute ## Loading required package: lattice ## This is vegan 2.5-7 library(flair) library(parallel) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(ggplot2) calc_rich&lt;-function(population){ population[population&gt;0]&lt;-T colSums(population) } fast_mean &lt;- function(x) { x&lt;-x[!is.na(x)] sum(x) / length(x) } calc_div&lt;-function(population){ relabund&lt;-population/rowSums(population) - rowSums(relabund* log(relabund)) } fitness_func &lt;- function(selection_parameter, optima, trait) { q = exp(((trait - optima)^2) / -selection_parameter) q } fitness_func_bacgen &lt;- function(selection_parameter,optima1, optima2, trait) { q = exp((((trait - mean(c(optima1, optima2)))^2))/ -selection_parameter) q } mutate_trait &lt;- function(trait, mutation_rate, mutation_sd) { mutated_trait &lt;- trait #+ rnorm(length(trait), mean = 0, sd = mutation_sd) mutate_mask &lt;- runif(length(trait)) &lt; mutation_rate mutated_trait[mutate_mask] &lt;- rnorm(sum(mutate_mask), mean = mutated_trait[mutate_mask], sd = mutation_sd) mutated_trait } Rcpp::sourceCpp(&#39;./calccpp_fit.cpp&#39;) sourceCpp(&quot;./withingen_process.cpp&quot;) sourceCpp(&quot;./env_production_withingen.cpp&quot;) knitr::opts_chunk$set(echo = TRUE) In our code we retain a lot information such as diversity, phenotypes/composite trait values, betadiversity, fitnesses, etc. It is better to calculate these as the simulation progresses rather than retaining every single generations data - because it is a lot of data that has to be saved and stored. We will start by generating an environmental matrix. This should be as many rows as you have host generations, and as many columns as you have microbial generations. In our paper, we generate environmental conditions for host generations, and interpolate between them smoothly for microbial generations, as seen in the code below. I will use an example environment here for white noise, similar to what is presented in our paper - the actual code for our environmental conditions is elsewhere in this repository. Below we present two plots - the first is at the scale of microbial generations based on 10 microbial generations per host generation. Hence it has 1,500 values - and is the result of smoothly interpolating between the environmental values at the host time scale (150 generations, the second plot). N_HostGens=150 start &lt;- seq(0.1, 0.1, length.out = N_HostGens*0.2) mid &lt;- seq(0.1, 0.3, length.out = N_HostGens*0.8) lowac_incvar&lt;-sapply(c(start,mid)*2.8, function(x){rnorm(1,0,x)}) expand_vector&lt;-function(vector, N) { expanded_vector &lt;- numeric() for (i in 1:(length(vector) - 1)) { expanded_vector &lt;- c(expanded_vector, vector[i], seq(vector[i], vector[i + 1], length.out = N)) } return(expanded_vector[1:(N*150)]) } env_vec&lt;-expand_vector(lowac_incvar,10) new_mat &lt;- matrix(env_vec,nrow = 150,ncol = 10,byrow = T) par(mfrow=c(1,2)) plot(env_vec,xlim=c(0,1500),ylab=&quot;Environmental Condition&quot;,xlab=&quot;Time point&quot;) plot(new_mat[,1],xlim=c(0,150),ylab=&quot;Environmental Condition&quot;,xlab=&quot;Host Generation&quot;) Now we can run a simulation: Host_PopSize= 100 MicrobePopSize=10^9 EnvPoolSize=10^9 N_Species =200 InitPopulation&lt;-matrix(nrow = N_Species, ncol=Host_PopSize) InitPopulation&lt;-apply(InitPopulation,MARGIN=2,FUN=function(x){ rmultinom(n=1,size = MicrobePopSize, prob =rep(1/N_Species,N_Species)) }) rownames(InitPopulation)&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) colnames(InitPopulation)&lt;-paste(&quot;Host&quot;,1:Host_PopSize,sep=&quot;_&quot;) EnvPool&lt;-rep(EnvPoolSize/N_Species,N_Species) names(EnvPool)&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) fixed_envpool&lt;-EnvPool traitpool_microbes&lt;-runif(N_Species,-1,1) names(traitpool_microbes)&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) mnames&lt;-colnames(InitPopulation) host_microbe_optima&lt;-rep(0,Host_PopSize) names(host_microbe_optima)&lt;-mnames microbiome_importances&lt;-rep(1,Host_PopSize) names(microbiome_importances)&lt;-mnames combination=c( 0.5, #Proportion of vertical inheritance 0.05, #Proportion of host &#39;shedding&#39; to the environment. 0.8) #Proportion of environmental pool which contributes to subsequent environmental pool. simulation_test &lt;- lapply_wrapper_CPP( XY = combination, HostPopulation = InitPopulation, N_Microbes = MicrobePopSize, envpoolsize = EnvPoolSize, env_pool = EnvPool, generations = nrow(new_mat), fixed_envpool = fixed_envpool, selection_parameter_hosts = 1, selection_parameter_microbes = 1, traitpool_microbes = traitpool_microbes, host_microbe_optima = host_microbe_optima, selection_parameter_env = 1, env_cond_val = new_mat, N_Species = N_Species, microbiome_importances = microbiome_importances, per_host_bac_gens = ncol(new_mat), self_seed_prop = 0.98, generation_data_file = NA, mutation_rate = 0.0, mutation_sd = 0.0, print_currentgen = F ) ## [1] &quot;Current X Value is 0.5 Current EnvCon value is 0.05&quot; We’ve done a simulation above, so here I will just make a demonstration figure. Most of the useful data is stored within “GenData” - which contains data from every host generation. MicrobialFitnesses&lt;-vector() HostFitnesses&lt;-vector() for(i in seq_along(simulation_test[[1]]$GenData)){ MicrobialFitnesses[i]&lt;- mean(simulation_test[[1]]$GenData[[i]]$MicrobeFitness) HostFitnesses[i]&lt;- mean(simulation_test[[1]]$GenData[[i]]$HostFitness) } par(mfrow=c(1,2)) plot(HostFitnesses,xlab=&quot;Generation&quot;,ylab=&quot;Host Fitness&quot;) plot(MicrobialFitnesses,xlab=&quot;Generation&quot;,ylab=&quot;Microbial Fitness&quot;) "]]
