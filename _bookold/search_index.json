[["paper-1---effective-vertical-inheritance.html", "3 Paper 1 - Effective vertical inheritance 3.1 Running an effective VI simulation", " 3 Paper 1 - Effective vertical inheritance pre.r + pre.r { margin-top: -1em; border-top-left-radius: 0; border-top-right-radius: 0; border-top: none; } .badCode { background-color: #c9fffb; color:black; } As we discuss in our paper, we include a comparison of vertical inheritance levels. We term ‘effective’ vertical inheritance as the proportion of parental microbes which are inherited at the point at which a host reproduces. For example, if a host inherits 99% of its microbes from its parents - but then lives for 100 microbial generations, the effective vertical inheritance will be lower than for 50 microbial generations due to acquistion of microbes from the environment, and the loss of parental microbes. We address this by running some bespoke simulations where at the 500th host generation, we label parental microbes and track their abundance over the course of a host generation. We do this for each environmental condition. This works in ‘janky’ way initializing the simulation with 400 ‘species’ slots, of which only 200 are occupied. At generation 498 we copy the parental microbes into the additional 200 slots which are called “VI_Spec_X” etc, and then we track the abundance of these over the course of the simulation in the subsequent generation. To properly test this - we first calculate the effective vertical inheritance, and then run our simulations as normal except we set microbial generation counts to 1, and we substitute the vertical inheritance values for the effective vertical inheritance values obtained for a generation count of interest. For example, in the following simulation we are interested in comparing the fitnesses of hosts with 50 microbial generations - while account for effective vertical inheritance. To address this, we will run a effective vertical inheritance simulation with 50 generations. We then determine what the effective vertical inheritance is, and then use that value as the effective vertical inheritance in a normal simulation where microbial generation count is 1. This allows to see if the benefits to host from microbial generation counts is the result of optimized vertical inheritance (in which case, fitnesses should be equivalent in both simulations) - or whether generation count itself is beneficial. Most of the code is relatively unchanged from normal. The key difference is the use of a modified create_offspring_loop.cpp function. knitr::opts_chunk$set(echo = TRUE) library(readr) library(reshape2) library(Rcpp) library(vegan) ## Loading required package: permute ## Loading required package: lattice ## This is vegan 2.5-7 library(parallel) library(ggplot2) num_unique_values &lt;- function(vec) { length(unique(vec)) } # Function to calculate average distance between values average_distance &lt;- function(vec) { n &lt;- length(vec) total_distance &lt;- 0 total_pairs &lt;- 0 for (i in 1:(n - 1)) { for (j in (i + 1):n) { total_distance &lt;- total_distance + abs(vec[i] - vec[j]) total_pairs &lt;- total_pairs + 1 } } total_distance / total_pairs } extract_pref_optima&lt;-function(x){ do.call(&quot;rbind&quot;,lapply(x[[1]]$GenData,function(y){(y$HostPrefOptima)})) } extract_fitnesses&lt;-function(data,rel_log_gen){ gendata=data$GenData data2use=lapply(gendata,function(q){ env_microbe_fitness_changes&lt;-mean((q$env_fits))#/x[[1]]$GenData[[500]]$env_fits)) host_microbe_fitness_changes&lt;-mean((q$MicrobeFitness))#/x[[1]]$GenData[[500]]$MicrobeFitness)) host_fitness_changes&lt;-mean((q$HostFitness))#/x[[1]]$GenData[[500]]$HostFitness)) gen_of_int_fitness_host&lt;-mean(gendata[[rel_log_gen]]$HostFitness) gen_of_int_fitness_microbe&lt;-mean(gendata[[rel_log_gen]]$MicrobeFitness) host_microbe_coeff=lm(q$MicrobeFitness~q$HostFitness) host_microbe_coeff&lt;-summary(host_microbe_coeff)$coefficients host_microbe_coeff&lt;-as.data.frame(host_microbe_coeff)$Estimate[2] host_diversity&lt;-mean(q$Diversity) data.frame(EnvMicrobeFitness=env_microbe_fitness_changes, HostMicrobeFitness=host_microbe_fitness_changes, HostFitness=host_fitness_changes, diversity=host_diversity, gen_of_int_fitness_microbe=gen_of_int_fitness_microbe, gen_of_int_fitness_host=gen_of_int_fitness_host, host_microbe_coeff=host_microbe_coeff) } ) do.call(&quot;rbind&quot;,data2use) } calc_rich&lt;-function(population){ population[population&gt;0]&lt;-T colSums(population) } fast_mean &lt;- function(x) { x&lt;-x[!is.na(x)] sum(x) / length(x) } calc_div&lt;-function(population){ relabund&lt;-population/rowSums(population) - rowSums(relabund* log(relabund)) } fitness_func &lt;- function(selection_parameter, optima, trait) { q = exp(((trait - optima)^2) / -selection_parameter) q } fitness_func_bacgen &lt;- function(selection_parameter,optima1, optima2, trait) { q = exp((((trait - mean(c(optima1, optima2)))^2))/ -selection_parameter) q } mutate_trait &lt;- function(trait, mutation_rate, mutation_sd) { mutated_trait &lt;- trait #+ rnorm(length(trait), mean = 0, sd = mutation_sd) mutate_mask &lt;- runif(length(trait)) &lt; mutation_rate mutated_trait[mutate_mask] &lt;- rnorm(sum(mutate_mask), mean = mutated_trait[mutate_mask], sd = mutation_sd) mutated_trait } Rcpp::sourceCpp(&#39;./evi_code/calccpp_fit.cpp&#39;) sourceCpp(&quot;./evi_code/withingen_process.cpp&quot;) sourceCpp(&quot;./evi_code/env_production_withingen.cpp&quot;) Rcpp::sourceCpp(&quot;./evi_code/create_offspring_loop_vi.cpp&quot;) Below is the R code to run the effective vertical inheritance work, with blue highlighted code indicating that the code is bespoke for this section. Rcpp::sourceCpp(&quot;./evi_code/create_offspring_loop_vi.cpp&quot;) Create_OffSpring_Pop_cpp&lt;-function(host_pop,n_micro,env_pool,envpoolsize,X,fixed_envpool, selection_parameter_microbes,selection_parameter_hosts,microbe_trait_list, host_microbe_optima, N_Species,env_condition,generation){ microbe_names&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) ENV_sampling_probability&lt;-(env_pool)/envpoolsize #Calculate initial sampling probability based on environmental relative abundance names(ENV_sampling_probability)&lt;-names(env_pool) if(generation == 498){ offspring_population&lt;-offspring_loopfunc_vi(host_pop = host_pop,ENV_sampling_probability = ENV_sampling_probability, host_microbe_optima = host_microbe_optima, X = X, selection_parameter_microbes = selection_parameter_microbes, env_condition = env_condition,microbe_trait_list = microbe_trait_list, n_micro = n_micro,microbe_names = microbe_names) } else{ offspring_population&lt;-offspring_loopfunc(host_pop = host_pop,ENV_sampling_probability = ENV_sampling_probability, host_microbe_optima = host_microbe_optima, X = X, selection_parameter_microbes = selection_parameter_microbes, env_condition = env_condition,microbe_trait_list = microbe_trait_list, n_micro = n_micro,microbe_names = microbe_names) } offspring_population&lt;-list(offspring_population$host_pop,env_pool,microbe_trait_list,offspring_population$fitness_microbes, offspring_population$weighted_samplingprob) names(offspring_population)&lt;-c(&quot;Child&quot;,&quot;Env&quot;,&quot;microbe_trait_list&quot;,&quot;microbefitness&quot;,&quot;microbe_samplingprob&quot;) offspring_population } And the next section of code lapply_wrapper_CPP&lt;-function(XY, HostPopulation, N_Microbes, envpoolsize, env_pool,fixed_envpool,generations,per_host_bac_gens,self_seed_prop, selection_parameter_hosts,selection_parameter_microbes,host_trait_list,N_Species,traitpool_microbes, generation_data_file,selection_parameter_env,env_cond_val, microbiome_importances,host_microbe_optima,mutation_rate,mutation_sd,print_currentgen,env_type){ temp_list &lt;- list() print(paste(&quot;Current X Value is&quot;, XY[1], &quot;Current EnvCon value is&quot;, XY[2])) print(env_type) gen_data&lt;-list() microbe_names&lt;-paste(&quot;Microbe&quot;,1:N_Species,sep=&quot;_&quot;) env_used &lt;- NULL if(!nrow(env_cond_val) == generations){ print(&quot;env_cond_val should be a matrix of the same length as the number of generations you are simulating&quot;) stop() } init_microbial_fitness&lt;-matrix(NA,nrow = length(traitpool_microbes),ncol=length(host_microbe_optima)) for(i in 1:ncol(init_microbial_fitness)){ init_microbial_fitness[,i] &lt;- fitness_func_bacgen(selection_parameter = selection_parameter_microbes, optima1 = host_microbe_optima[i], optima2 = env_cond_val[1,1],trait = traitpool_microbes) } init_microbial_fitness&lt;-init_microbial_fitness#[HostPopulation&gt;0] init_microbial_fitness&lt;-weighted.mean(x = init_microbial_fitness,w = HostPopulation) init_host_fitness&lt;-vector() for(i in 1:ncol(HostPopulation)){ mean_microbial_trait_val&lt;- sum(traitpool_microbes * HostPopulation[,i])/N_Microbes composite_host_trait&lt;-((mean_microbial_trait_val * microbiome_importances[i]) + (host_microbe_optima[i] * (1-microbiome_importances[i]))) hostfitness&lt;-fitness_func(selection_parameter = selection_parameter_hosts, trait = composite_host_trait,optima = env_cond_val[1,1]) init_host_fitness[i]&lt;-hostfitness } if(!ncol(env_cond_val)==per_host_bac_gens){ print(&quot;Number of columns in env_conditions should be the number of bacterial generations&quot;) stop() } if(is.na(self_seed_prop)){ print(&quot;Self seeding proportion is NA, please correct&quot;) } for (generation in 1:generations) { if(generation ==1){ env_used&lt;-fixed_envpool } if(per_host_bac_gens == 1){ self_seed_prop=1 } env_cond_val_used&lt;-as.vector(env_cond_val[generation,]) vi_ests&lt;-matrix(NA,nrow = 400,ncol = 200) for(bacgen in 1:per_host_bac_gens){ if(XY[2] + XY[3] &gt; 1) { print(&quot;The contribution of the fixed environment (Y) and the the autocthonous environment (var_env_con) is greater than 1, please correct this &quot;) stop() } gen_env_cond&lt;-env_cond_val_used[bacgen] env_used&lt;-process_microbe_probs(env_cond_val = gen_env_cond, fixed_envpool = fixed_envpool, HostPopulation = HostPopulation, N_Microbes = N_Microbes, envpoolsize = envpoolsize, selection_parameter_env = selection_parameter_env, XY = XY, traitpool_microbes = traitpool_microbes,env_used = env_used ) env_fits&lt;-weighted.mean(x = env_used[,3],w = env_used[,8]) env_used&lt;-env_used[,8] names(env_used)&lt;-names(fixed_envpool)#rownames(microbe_probs) HostPopulation&lt;-process_host_cpp(HostPopulation = HostPopulation, selection_parameter_microbes = selection_parameter_microbes, host_microbe_optima = host_microbe_optima , env_condition = env_cond_val_used[bacgen], traitpool_microbes = traitpool_microbes, N_Microbes = N_Microbes, self_seed_prop = self_seed_prop,env_used = env_used) if(generation == 499){ vi_ests[,bacgen]&lt;-HostPopulation[,1] } } if(generation == 499){ write_rds(vi_ests,paste(&quot;X&quot;,env_type,XY[1],&quot;vi_ests.RDS&quot;,sep=&quot;_&quot;)) } host_fitnessvector&lt;-numeric() host_fitnessvector &lt;- calculate_host_fitness_cpp(as.matrix(HostPopulation), traitpool_microbes, microbiome_importances, host_microbe_optima, selection_parameter_hosts, env_cond_val_used[per_host_bac_gens]) nomicrobiomehost_fitnessvector&lt;-numeric() nomicrobiomehost_fitnessvector &lt;- calculate_host_fitness_cpp(as.matrix(HostPopulation), traitpool_microbes,rep(0,length(microbiome_importances)), host_microbe_optima, selection_parameter_hosts, env_cond_val_used[per_host_bac_gens]) hostfitness_abs&lt;-host_fitnessvector host_fitnessvector&lt;-host_fitnessvector#/mean(host_fitnessvector) HostPopulationInt&lt;-sample(colnames(HostPopulation),ncol(HostPopulation),replace = T,prob = host_fitnessvector) host_microbe_optima_prevgen&lt;-host_microbe_optima HostPopulation&lt;-HostPopulation[ , HostPopulationInt] host_microbe_optima&lt;-host_microbe_optima[HostPopulationInt] microbiome_importances&lt;-microbiome_importances[HostPopulationInt] if(mutation_rate&gt;0){ host_microbe_optima &lt;- mutate_trait(host_microbe_optima, mutation_rate, mutation_sd) } HostPopulation&lt;-as.matrix(HostPopulation) names(host_microbe_optima)&lt;-paste(&quot;Host&quot;,1:ncol(HostPopulation),sep=&quot;_&quot;) names(microbiome_importances)&lt;-paste(&quot;Host&quot;,1:ncol(HostPopulation),sep=&quot;_&quot;) if(print_currentgen==T){print(paste(&quot;Current Generation is&quot;, generation))} new_gen &lt;- Create_OffSpring_Pop_cpp(host_pop = HostPopulation, n_micro = N_Microbes, env_pool = env_used, envpoolsize = envpoolsize, X = XY[1], fixed_envpool = fixed_envpool, microbe_trait_list=traitpool_microbes, selection_parameter_microbes=selection_parameter_microbes, selection_parameter_hosts = selection_parameter_hosts, host_microbe_optima=host_microbe_optima, N_Species=N_Species, env_condition=env_cond_val_used[per_host_bac_gens], generation = generation) HostPopulation &lt;- new_gen$Child BrayDiv&lt;-vegdist(t(HostPopulation),method=&quot;bray&quot;) div_pergen&lt;-calc_div(t(new_gen$Child))/log(calc_rich(new_gen$Child)) new_gen$HostFitness_Abs&lt;-(hostfitness_abs) new_gen$nomicrobiomehost_fitnessvector&lt;-nomicrobiomehost_fitnessvector new_gen$BrayDiv&lt;-BrayDiv new_gen$HostMicrobeOptima&lt;-host_microbe_optima_prevgen gen_data[[generation]]&lt;-list(div_pergen,new_gen$HostFitness_Abs,new_gen$microbefitness,env_used, env_fits,new_gen$HostMicrobeOptima,new_gen$nomicrobiomehost_fitnessvector,new_gen$microbe_samplingprob, microbiome_importances,new_gen$BrayDiv) names(gen_data[[generation]])&lt;-c(&quot;Diversity&quot;,&quot;HostFitness&quot;,&quot;MicrobeFitness&quot;,&quot;env_used&quot;,&quot;env_fits&quot; ,&quot;HostMicrobeOptima&quot;,&quot;nomicrobiomehost_fitnessvector&quot;, &quot;microbe_samplingprob&quot;,&quot;microbiome_importances&quot;,&quot;BrayDiv&quot;)#,&quot;HostPrefOptima&quot;,&quot;HostMicrobeOptima&quot;) } new_gen$GenData&lt;-gen_data new_gen$init_host_fitness&lt;-init_host_fitness new_gen$init_microbe_fitness&lt;-init_microbial_fitness temp_list[[paste0(&quot;X&quot;, XY[1], &quot;_Y&quot;, XY[2],&quot;_EnvCont&quot;,XY[3],&quot;_HostSel&quot;,XY[4],&quot;_MicrobeSel&quot;,XY[5])]] &lt;- new_gen temp_list } 3.1 Running an effective VI simulation Host_PopSize= 100 MicrobePopSize=10^9#0000 #n_micro EnvPoolSize=10^9#0000 N_Species =400 InitPopulation&lt;-matrix(nrow = 200, ncol=Host_PopSize) InitPopulation&lt;-apply(InitPopulation,MARGIN=2,FUN=function(x){ rmultinom(n=1,size = MicrobePopSize, prob =rep(1/200,200)) }) rownames(InitPopulation)&lt;-paste(&quot;Microbe&quot;,1:200,sep=&quot;_&quot;) colnames(InitPopulation)&lt;-paste(&quot;Host&quot;,1:Host_PopSize,sep=&quot;_&quot;) VI_InitPopulation&lt;-matrix(data=0,nrow = 200, ncol=Host_PopSize) rownames(VI_InitPopulation)&lt;-paste(&quot;VI_Microbe&quot;,1:200,sep=&quot;_&quot;) colnames(VI_InitPopulation)&lt;-paste(&quot;Host&quot;,1:Host_PopSize,sep=&quot;_&quot;) InitPopulation&lt;-rbind(InitPopulation,VI_InitPopulation) EnvPool&lt;-rep(EnvPoolSize/200,200) names(EnvPool)&lt;-paste(&quot;Microbe&quot;,1:200,sep=&quot;_&quot;) VI_EnvPool&lt;-rep(0,200) names(VI_EnvPool)&lt;-paste(&quot;VI_Microbe&quot;,1:200,sep=&quot;_&quot;) EnvPool&lt;-c(EnvPool,VI_EnvPool) fixed_envpool&lt;-EnvPool traitpool_microbes&lt;-runif(200,-1,1) traitpool_microbes&lt;-c(traitpool_microbes,traitpool_microbes) names(traitpool_microbes)&lt;-names(EnvPool) mnames&lt;-colnames(InitPopulation) host_microbe_optima&lt;-rep(0,Host_PopSize) names(host_microbe_optima)&lt;-mnames microbiome_importances&lt;-rep(1,Host_PopSize)#runif(Host_PopSize,0,1) names(microbiome_importances)&lt;-mnames N_HostGens=800 start &lt;- seq(0.1, 0.1, length.out = N_HostGens*0.2) mid &lt;- seq(0.1, 0.3, length.out = N_HostGens*0.8) lowac_incvar&lt;-sapply(c(start,mid)*2.8, function(x){rnorm(1,0,x)}) expand_vector&lt;-function(vector, N) { expanded_vector &lt;- numeric() for (i in 1:(length(vector) - 1)) { expanded_vector &lt;- c(expanded_vector, vector[i], seq(vector[i], vector[i + 1], length.out = N)) } return(expanded_vector[1:(N*800)]) } env_vec&lt;-expand_vector(lowac_incvar,10) new_mat &lt;- matrix(env_vec,nrow = 800,ncol = 10,byrow = T) combination=c( 0.5, #Proportion of vertical inheritance 0.05, #Proportion of host &#39;shedding&#39; to the environment. 0.8) #Proportion of environmental pool which contributes to subsequent environmental pool. envtype&lt;-as.character(&quot;DummyEnv&quot;) simulation_test &lt;- lapply_wrapper_CPP( XY = combination, HostPopulation = InitPopulation, N_Microbes = MicrobePopSize, envpoolsize = EnvPoolSize, env_pool = EnvPool, generations = nrow(new_mat), fixed_envpool = fixed_envpool, selection_parameter_hosts = 1, selection_parameter_microbes = 1, traitpool_microbes = traitpool_microbes, host_microbe_optima = host_microbe_optima, selection_parameter_env = 1, env_cond_val = new_mat, N_Species = N_Species, microbiome_importances = microbiome_importances, per_host_bac_gens = ncol(new_mat), self_seed_prop = 0.98, generation_data_file = NA, mutation_rate = 0.0, mutation_sd = 0.0, print_currentgen = F, env_type=envtype ) We have now run a simulation where we have measured effective vertical inheritance. We can analysis this as follows: viests&lt;-list.files(pattern=&quot;X*ests.RDS&quot;) viests&lt;-lapply(viests,read_rds) viests&lt;-lapply(viests,function(q){ colSums(q[201:400,])/colSums(q) }) names(viests)&lt;-list.files(pattern=&quot;X*ests.RDS&quot;) viests&lt;-do.call(&quot;rbind&quot;,viests) viests&lt;-reshape2::melt(viests) viests&lt;-viests[complete.cases(viests),] viests$InitVert&lt;- gsub(&quot;.RDS&quot;,&quot;&quot;,viests$Var1) viests$InitVert&lt;- stringr::word(viests$InitVert,3,sep=&quot;_&quot;) #viests$InitVert&lt;-gsub(&quot;[^0-9.-]&quot;, &quot;&quot;, viests$InitVert) efi_relationship&lt;-ggplot(viests) + aes(x = Var2, y = value, colour = InitVert) + geom_line(linewidth=2) + scale_color_hue(direction = 1) + theme_minimal() + xlab(&quot;Microbial Generations within a host&quot;) + ylab(&quot;Proportion of Vertical Acquired Microbes remaining&quot;) #+ facet_wrap(~Environment) efi_relationship We can now see that at microbial generation 10 the effective vertical inheritance is approximately 0.38 - despite hosts initially obtaining 50% of their microbiome from their parent. "]]
